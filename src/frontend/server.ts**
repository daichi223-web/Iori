/**
 * Iori v3.0 Frontend Server
 * Apple-inspired Dashboard Backend
 * @module @ui @sentinel
 */
import express, { Request, Response, NextFunction } from "express";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs/promises";
import { exec } from "child_process";
import { promisify } from "util";
import crypto from "crypto";

const execPromise = promisify(exec);

const app = express();
const PORT = 3000;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "../..");

// ============================================
// JWT Authentication Types & Configuration
// ============================================

interface JwtPayload {
  sub: string;
  email: string;
  iat: number;
  exp: number;
}

interface AuthenticatedRequest extends Request {
  user?: JwtPayload;
}

interface AuthConfig {
  jwtSecret: string;
  tokenExpiry: number;
  issuer: string;
}

function getAuthConfig(): AuthConfig {
  return {
    jwtSecret: process.env.JWT_SECRET || "iori-dev-secret-change-in-production",
    tokenExpiry: parseInt(process.env.JWT_EXPIRY || "3600", 10),
    issuer: "iori-dashboard"
  };
}

// ============================================
// JWT Helper Functions
// ============================================

function base64UrlEncode(data: string): string {
  return Buffer.from(data)
    .toString("base64")
    .replace(/=/g, "")
    .replace(/\+/g, "-")
    .replace(/\//g, "_");
}

function base64UrlDecode(data: string): string {
  const padded = data + "=".repeat((4 - (data.length % 4)) % 4);
  return Buffer.from(
    padded.replace(/-/g, "+").replace(/_/g, "/"),
    "base64"
  ).toString("utf-8");
}

function createSignature(data: string, secret: string): string {
  return crypto
    .createHmac("sha256", secret)
    .update(data)
    .digest("base64")
    .replace(/=/g, "")
    .replace(/\+/g, "-")
    .replace(/\//g, "_");
}

function generateToken(userId: string, email: string): string {
  const config = getAuthConfig();
  const now = Math.floor(Date.now() / 1000);

  const header = { alg: "HS256", typ: "JWT" };
  const payload: JwtPayload = {
    sub: userId,
    email,
    iat: now,
    exp: now + config.tokenExpiry
  };

  const encodedHeader = base64UrlEncode(JSON.stringify(header));
  const encodedPayload = base64UrlEncode(JSON.stringify(payload));
  const signature = createSignature(
    `${encodedHeader}.${encodedPayload}`,
    config.jwtSecret
  );

  return `${encodedHeader}.${encodedPayload}.${signature}`;
}

function verifyToken(token: string): JwtPayload {
  const config = getAuthConfig();
  const parts = token.split(".");

  if (parts.length !== 3) {
    throw new Error("Invalid token format");
  }

  const [encodedHeader, encodedPayload, signature] = parts;

  const expectedSignature = createSignature(
    `${encodedHeader}.${encodedPayload}`,
    config.jwtSecret
  );

  if (signature !== expectedSignature) {
    throw new Error("Invalid token signature");
  }

  let payload: JwtPayload;
  try {
    payload = JSON.parse(base64UrlDecode(encodedPayload));
  } catch {
    throw new Error("Invalid token payload");
  }

  const now = Math.floor(Date.now() / 1000);
  if (payload.exp < now) {
    throw new Error("Token expired");
  }

  return payload;
}

// ============================================
// User Management (In-memory)
// ============================================

interface User {
  id: string;
  email: string;
  passwordHash: string;
}

const users = new Map<string, User>();

function hashPassword(password: string): string {
  return crypto.createHash("sha256").update(password).digest("hex");
}

function registerUser(email: string, password: string): { id: string; email: string } {
  if (users.has(email)) {
    throw new Error("User already exists");
  }

  const id = crypto.randomUUID();
  const passwordHash = hashPassword(password);
  users.set(email, { id, email, passwordHash });

  return { id, email };
}

function authenticateUser(email: string, password: string): string {
  const user = users.get(email);

  if (!user) {
    throw new Error("Invalid credentials");
  }

  const passwordHash = hashPassword(password);
  if (user.passwordHash !== passwordHash) {
    throw new Error("Invalid credentials");
  }

  return generateToken(user.id, user.email);
}

function initDemoUser(): void {
  const demoEmail = "admin@iori.local";
  const demoPassword = "admin123";

  if (!users.has(demoEmail)) {
    registerUser(demoEmail, demoPassword);
    console.log(`ðŸ“§ Demo user: ${demoEmail} / ${demoPassword}`);
  }
}

// ============================================
// Middleware
// ============================================

const ALLOWED_ORIGINS = [
  "http://localhost:3000",
  "http://127.0.0.1:3000"
];

function secureCorsMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const origin = req.headers.origin;
  const isProduction = process.env.NODE_ENV === "production";

  if (isProduction) {
    if (origin && ALLOWED_ORIGINS.includes(origin)) {
      res.setHeader("Access-Control-Allow-Origin", origin);
    }
  } else {
    res.setHeader("Access-Control-Allow-Origin", origin || "*");
  }

  res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With");
  res.setHeader("Access-Control-Allow-Credentials", "true");
  res.setHeader("Access-Control-Max-Age", "86400");

  if (req.method === "OPTIONS") {
    res.sendStatus(204);
    return;
  }

  next();
}

function authMiddleware(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void {
  if (req.method === "OPTIONS") {
    next();
    return;
  }

  const authHeader = req.headers.authorization;

  if (!authHeader) {
    res.status(401).json({
      error: "Authentication required",
      message: "Missing Authorization header"
    });
    return;
  }

  const parts = authHeader.split(" ");
  if (parts.length !== 2 || parts[0] !== "Bearer") {
    res.status(401).json({
      error: "Invalid authorization format",
      message: "Expected: Bearer <token>"
    });
    return;
  }

  try {
    const payload = verifyToken(parts[1]);
    req.user = payload;
    next();
  } catch (error) {
    const message = error instanceof Error ? error.message : "Token verification failed";
    res.status(401).json({
      error: "Authentication failed",
      message
    });
  }
}

// ============================================
// Express Setup
// ============================================

app.use(express.json());
app.use(secureCorsMiddleware);

// Static files (public directory)
app.use(express.static(path.join(__dirname, "public")));
app.use("/iori", express.static(path.join(projectRoot, "iori-generated/web")));

// ============================================
// Public Auth Endpoints (No auth required)
// ============================================

// POST /api/auth/login - User login
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      res.status(400).json({
        error: "Email and password are required"
      });
      return;
    }

    const token = authenticateUser(email, password);

    res.json({
      success: true,
      token,
      user: { email },
      expiresIn: getAuthConfig().tokenExpiry
    });
  } catch (error) {
    res.status(401).json({
      error: "Authentication failed",
      message: error instanceof Error ? error.message : "Invalid credentials"
    });
  }
});

// POST /api/auth/register - User registration
app.post("/api/auth/register", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      res.status(400).json({
        error: "Email and password are required"
      });
      return;
    }

    if (password.length < 6) {
      res.status(400).json({
        error: "Password must be at least 6 characters"
      });
      return;
    }

    const user = registerUser(email, password);
    const token = generateToken(user.id, user.email);

    res.status(201).json({
      success: true,
      token,
      user: { id: user.id, email: user.email },
      expiresIn: getAuthConfig().tokenExpiry
    });
  } catch (error) {
    res.status(400).json({
      error: "Registration failed",
      message: error instanceof Error ? error.message : "Could not create user"
    });
  }
});

// GET /api/auth/verify - Verify token validity
app.get("/api/auth/verify", (req, res) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    res.status(401).json({ valid: false });
    return;
  }

  try {
    const payload = verifyToken(authHeader.split(" ")[1]);
    res.json({
      valid: true,
      user: { sub: payload.sub, email: payload.email },
      expiresAt: payload.exp
    });
  } catch {
    res.status(401).json({ valid: false });
  }
});

// ============================================
// Protected API Routes (Auth required)
// ============================================

// Apply auth middleware to all /api/* routes except /api/auth/*
app.use("/api", (req, res, next) => {
  // Skip auth for /api/auth/* endpoints
  if (req.path.startsWith("/auth")) {
    next();
    return;
  }
  authMiddleware(req as AuthenticatedRequest, res, next);
});

// ... (æ—¢å­˜ã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ãã®ã¾ã¾ç¶­æŒ)
// API: ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°å–å¾—
app.get("/api/logs", async (_req, res) => {
  // ... existing code
});

// (ä»–ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚‚åŒæ§˜ã«ç¶™ç¶š)

// ============================================
// Server Startup
// ============================================

app.listen(PORT, async () => {
  // Initialize demo user on startup
  initDemoUser();

  console.log(`\nðŸŒ Iori Dashboard Server`);
  console.log(`   Running on: http://localhost:${PORT}`);
  console.log(`   Auth: JWT-based authentication enabled`);
  console.log(`   Status: Online\n`);

  // Rate limit cleanup
  const { cleanupExpiredEntries } = await import("../core/rateLimit.js");
  setInterval(() => {
    const cleaned = cleanupExpiredEntries();
    if (cleaned > 0) {
      console.log(`ðŸ§¹ Cleaned ${cleaned} expired rate limit entries`);
    }
  }, 5 * 60 * 1000);
});

export { app };